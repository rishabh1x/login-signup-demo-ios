//
//  EmailVerifyModels.swift
//  Basis-Auth-Demo
//
//  Created by rishabh on 05/05/22.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

enum EmailVerify
{
    // MARK: Use cases
    
    enum GetEmail
    {
        struct Request
        {
            
        }
        struct Response
        {
            var email: String
        }
        struct ViewModel
        {
            var strEmail: String
        }
    }
    enum VerifyAction {
        struct Request {
            var code: Int
        }
        struct Response {
            var success: Bool
            var email: String
            var code: Int
            var isLogin: Bool?
        }
        struct ViewModel {
            var success: Bool
        }
    }
    enum VerifyActionAPI {
        struct VerifyActionAPIModel: Codable {
            let success: Bool?
            let version: Version?
            let statusCode: Int?
            let responseCode, message: String?
            let results: Results?
        }
        
        // MARK: - Results
        struct Results: Codable {
            let isLogin: Bool?
            let wrongEmailTokenCount, resendEmailTokenCount: Int?
            let user: User?
        }
        
        // MARK: - User
        struct User: Codable {
            let id: String?
            let avatar: String?
            let firstName, lastName, phoneNumber: String?
            let phoneNumberVerified: Bool?
            let email: String?
            let emailVerified, investmentSubscribed: Bool?
            let rewards, nextGoal: Int?
            let referralToken, referralMessage: String?
            let referralCount: Int?
            let badges: [JSONAny]?
            let onboardingStatus: String?
            let status: [String: Bool]?
            let kycDetails: KycDetails?
            let token: String?
            let nextLesson: NextLesson?
            let hasMadeInvestments, isMandateApproved: Bool?
            let rewardKeys: [JSONAny]?
            let hasAnsweredQuestions: Bool?
            let unsubscribe: [JSONAny]?
            let profession, expertise: String?
            let privacy: Privacy?
            let basisStates, customToken: String?
            let basisTeam: Bool?
            let communityAcceptance: Int?
            let creditCardState: String?
            
            enum CodingKeys: String, CodingKey {
                case id = "_id"
                case avatar, firstName, lastName, phoneNumber, phoneNumberVerified, email, emailVerified, investmentSubscribed, rewards, nextGoal, referralToken, referralMessage, referralCount, badges, onboardingStatus, status, kycDetails, token, nextLesson, hasMadeInvestments, isMandateApproved, rewardKeys, hasAnsweredQuestions, unsubscribe, profession, expertise, privacy, basisStates, customToken, basisTeam, communityAcceptance, creditCardState
            }
        }
        
        // MARK: - KycDetails
        struct KycDetails: Codable {
        }
        
        // MARK: - NextLesson
        struct NextLesson: Codable {
            let lesson: Lesson?
            let module: Module?
        }
        
        // MARK: - Lesson
        struct Lesson: Codable {
            let active: Bool?
            let id, title: String?
            let position: Int?
            let likedByUsersID: [String]?
            let cards: [Card]?
            
            enum CodingKeys: String, CodingKey {
                case active
                case id = "_id"
                case title, position
                case likedByUsersID = "likedByUsersId"
                case cards
            }
        }
        
        // MARK: - Card
        struct Card: Codable {
            let id: String?
            let position: Int?
            let type: String?
        }
        
        // MARK: - Module
        struct Module: Codable {
            let id, title: String?
            let position, rewards: Int?
            
            enum CodingKeys: String, CodingKey {
                case id = "_id"
                case title, position, rewards
            }
        }
        
        // MARK: - Privacy
        struct Privacy: Codable {
            let emailPrivacy, professionPrivacy, locationPrivacy: String?
        }
        
        // MARK: - Version
        struct Version: Codable {
            let minimum, current: Int?
        }
        
        // MARK: - Encode/decode helpers
        
        class JSONNull: Codable, Hashable {
            
            public static func == (lhs: JSONNull, rhs: JSONNull) -> Bool {
                return true
            }
            
            public var hashValue: Int {
                return 0
            }
            
            public func hash(into hasher: inout Hasher) {
                // No-op
            }
            
            public init() {}
            
            public required init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if !container.decodeNil() {
                    throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for JSONNull"))
                }
            }
            
            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                try container.encodeNil()
            }
        }
        
        class JSONCodingKey: CodingKey {
            let key: String
            
            required init?(intValue: Int) {
                return nil
            }
            
            required init?(stringValue: String) {
                key = stringValue
            }
            
            var intValue: Int? {
                return nil
            }
            
            var stringValue: String {
                return key
            }
        }
        
        class JSONAny: Codable {
            
            let value: Any
            
            static func decodingError(forCodingPath codingPath: [CodingKey]) -> DecodingError {
                let context = DecodingError.Context(codingPath: codingPath, debugDescription: "Cannot decode JSONAny")
                return DecodingError.typeMismatch(JSONAny.self, context)
            }
            
            static func encodingError(forValue value: Any, codingPath: [CodingKey]) -> EncodingError {
                let context = EncodingError.Context(codingPath: codingPath, debugDescription: "Cannot encode JSONAny")
                return EncodingError.invalidValue(value, context)
            }
            
            static func decode(from container: SingleValueDecodingContainer) throws -> Any {
                if let value = try? container.decode(Bool.self) {
                    return value
                }
                if let value = try? container.decode(Int64.self) {
                    return value
                }
                if let value = try? container.decode(Double.self) {
                    return value
                }
                if let value = try? container.decode(String.self) {
                    return value
                }
                if container.decodeNil() {
                    return JSONNull()
                }
                throw decodingError(forCodingPath: container.codingPath)
            }
            
            static func decode(from container: inout UnkeyedDecodingContainer) throws -> Any {
                if let value = try? container.decode(Bool.self) {
                    return value
                }
                if let value = try? container.decode(Int64.self) {
                    return value
                }
                if let value = try? container.decode(Double.self) {
                    return value
                }
                if let value = try? container.decode(String.self) {
                    return value
                }
                if let value = try? container.decodeNil() {
                    if value {
                        return JSONNull()
                    }
                }
                if var container = try? container.nestedUnkeyedContainer() {
                    return try decodeArray(from: &container)
                }
                if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self) {
                    return try decodeDictionary(from: &container)
                }
                throw decodingError(forCodingPath: container.codingPath)
            }
            
            static func decode(from container: inout KeyedDecodingContainer<JSONCodingKey>, forKey key: JSONCodingKey) throws -> Any {
                if let value = try? container.decode(Bool.self, forKey: key) {
                    return value
                }
                if let value = try? container.decode(Int64.self, forKey: key) {
                    return value
                }
                if let value = try? container.decode(Double.self, forKey: key) {
                    return value
                }
                if let value = try? container.decode(String.self, forKey: key) {
                    return value
                }
                if let value = try? container.decodeNil(forKey: key) {
                    if value {
                        return JSONNull()
                    }
                }
                if var container = try? container.nestedUnkeyedContainer(forKey: key) {
                    return try decodeArray(from: &container)
                }
                if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key) {
                    return try decodeDictionary(from: &container)
                }
                throw decodingError(forCodingPath: container.codingPath)
            }
            
            static func decodeArray(from container: inout UnkeyedDecodingContainer) throws -> [Any] {
                var arr: [Any] = []
                while !container.isAtEnd {
                    let value = try decode(from: &container)
                    arr.append(value)
                }
                return arr
            }
            
            static func decodeDictionary(from container: inout KeyedDecodingContainer<JSONCodingKey>) throws -> [String: Any] {
                var dict = [String: Any]()
                for key in container.allKeys {
                    let value = try decode(from: &container, forKey: key)
                    dict[key.stringValue] = value
                }
                return dict
            }
            
            static func encode(to container: inout UnkeyedEncodingContainer, array: [Any]) throws {
                for value in array {
                    if let value = value as? Bool {
                        try container.encode(value)
                    } else if let value = value as? Int64 {
                        try container.encode(value)
                    } else if let value = value as? Double {
                        try container.encode(value)
                    } else if let value = value as? String {
                        try container.encode(value)
                    } else if value is JSONNull {
                        try container.encodeNil()
                    } else if let value = value as? [Any] {
                        var container = container.nestedUnkeyedContainer()
                        try encode(to: &container, array: value)
                    } else if let value = value as? [String: Any] {
                        var container = container.nestedContainer(keyedBy: JSONCodingKey.self)
                        try encode(to: &container, dictionary: value)
                    } else {
                        throw encodingError(forValue: value, codingPath: container.codingPath)
                    }
                }
            }
            
            static func encode(to container: inout KeyedEncodingContainer<JSONCodingKey>, dictionary: [String: Any]) throws {
                for (key, value) in dictionary {
                    let key = JSONCodingKey(stringValue: key)!
                    if let value = value as? Bool {
                        try container.encode(value, forKey: key)
                    } else if let value = value as? Int64 {
                        try container.encode(value, forKey: key)
                    } else if let value = value as? Double {
                        try container.encode(value, forKey: key)
                    } else if let value = value as? String {
                        try container.encode(value, forKey: key)
                    } else if value is JSONNull {
                        try container.encodeNil(forKey: key)
                    } else if let value = value as? [Any] {
                        var container = container.nestedUnkeyedContainer(forKey: key)
                        try encode(to: &container, array: value)
                    } else if let value = value as? [String: Any] {
                        var container = container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key)
                        try encode(to: &container, dictionary: value)
                    } else {
                        throw encodingError(forValue: value, codingPath: container.codingPath)
                    }
                }
            }
            
            static func encode(to container: inout SingleValueEncodingContainer, value: Any) throws {
                if let value = value as? Bool {
                    try container.encode(value)
                } else if let value = value as? Int64 {
                    try container.encode(value)
                } else if let value = value as? Double {
                    try container.encode(value)
                } else if let value = value as? String {
                    try container.encode(value)
                } else if value is JSONNull {
                    try container.encodeNil()
                } else {
                    throw encodingError(forValue: value, codingPath: container.codingPath)
                }
            }
            
            public required init(from decoder: Decoder) throws {
                if var arrayContainer = try? decoder.unkeyedContainer() {
                    self.value = try JSONAny.decodeArray(from: &arrayContainer)
                } else if var container = try? decoder.container(keyedBy: JSONCodingKey.self) {
                    self.value = try JSONAny.decodeDictionary(from: &container)
                } else {
                    let container = try decoder.singleValueContainer()
                    self.value = try JSONAny.decode(from: container)
                }
            }
            
            public func encode(to encoder: Encoder) throws {
                if let arr = self.value as? [Any] {
                    var container = encoder.unkeyedContainer()
                    try JSONAny.encode(to: &container, array: arr)
                } else if let dict = self.value as? [String: Any] {
                    var container = encoder.container(keyedBy: JSONCodingKey.self)
                    try JSONAny.encode(to: &container, dictionary: dict)
                } else {
                    var container = encoder.singleValueContainer()
                    try JSONAny.encode(to: &container, value: self.value)
                }
            }
        }
        
    }
}
